use crate::files::{FileManager, FileType};
use serde::{Deserialize, Serialize};

pub const WINDOW_MARGIN: &str = "window_margin";
pub const ALLOW_SELECTING_SAME_CENTER_WINDOWS: &str = "allow_selecting_same_center_windows";
pub const FORCE_USING_ADMIN_PRIVILEGES: &str = "force_using_admin_privileges";
pub const ADDITIONAL_WORKSPACE_COUNT: &str = "additional_workspace_count";
pub const ENABLE_FEATURES_USING_MOUSE: &str = "enable_features_using_mouse";
pub const DELAY_IN_MS_BEFORE_DRAGGING_IS_ALLOWED: &str = "delay_in_ms_before_dragging_is_allowed";
pub const ALLOW_MOVING_CURSOR_AFTER_OPEN_CLOSE_OR_MINIMISE: &str = "allow_moving_cursor_on_close_or_minimise";

const CONFIGURATION_FILE_NAME: &str = "randolf.toml";
const CONFIGURATION_FILE_PREFIX: &str = "# This file is automatically generated and can be updated by you and by Randolf.\n\
  # It stores your Randolf configuration. See https://github.com/kimgoetzke/randolf for details.\n\n";
const DEFAULT_WINDOW_MARGIN_VALUE: i32 = 20;
const DEFAULT_DELAY_IN_MS_BEFORE_DRAGGING_IS_ALLOWED: i32 = 750;

#[derive(Debug, Serialize, Deserialize, Default)]
struct Configuration {
  pub general: GeneralConfiguration,
  #[serde(default)]
  pub hotkey: Vec<CustomHotkey>,
  #[serde(default)]
  pub exclusion_settings: ExclusionSettings,
}

#[derive(Debug, Serialize, Deserialize)]
struct GeneralConfiguration {
  #[serde(default = "default_window_margin")]
  window_margin: i32,
  #[serde(default = "default_allow_selecting_same_center_windows")]
  allow_selecting_same_center_windows: bool,
  #[serde(default = "default_force_using_admin_privileges")]
  force_using_admin_privileges: bool,
  #[serde(default = "default_additional_workspace_count")]
  additional_workspace_count: i32,
  #[serde(default = "default_enable_features_using_mouse")]
  enable_features_using_mouse: bool,
  #[serde(default = "default_delay_in_ms_before_dragging_is_allowed")]
  delay_in_ms_before_dragging_is_allowed: i32,
  #[serde(default = "allow_moving_cursor_after_close_or_minimise")]
  allow_moving_cursor_after_close_or_minimise: bool,
}

fn default_window_margin() -> i32 {
  DEFAULT_WINDOW_MARGIN_VALUE
}

fn validate_window_margin(config_str: &str, configuration_provider: &mut ConfigurationProvider) {
  if !config_str.contains(WINDOW_MARGIN) {
    warn!(
      "[{}] was missing; adding it now with default value: {}",
      WINDOW_MARGIN, DEFAULT_WINDOW_MARGIN_VALUE
    );
    configuration_provider.set_i32(WINDOW_MARGIN, DEFAULT_WINDOW_MARGIN_VALUE);
  } else if configuration_provider.config.general.window_margin <= 0 {
    warn!(
      "[{}] is 0 or negative, setting to default value: {}",
      WINDOW_MARGIN, DEFAULT_WINDOW_MARGIN_VALUE
    );
    configuration_provider.set_i32(WINDOW_MARGIN, DEFAULT_WINDOW_MARGIN_VALUE);
  }
}

fn default_allow_selecting_same_center_windows() -> bool {
  true
}

fn validate_allow_selecting_same_center_windows(config_str: &str, configuration_provider: &mut ConfigurationProvider) {
  if !config_str.contains(ALLOW_SELECTING_SAME_CENTER_WINDOWS) {
    warn!(
      "[{}] was missing; adding it now with default value: {}",
      ALLOW_SELECTING_SAME_CENTER_WINDOWS,
      default_allow_selecting_same_center_windows()
    );
    configuration_provider.set_bool(
      ALLOW_SELECTING_SAME_CENTER_WINDOWS,
      default_allow_selecting_same_center_windows(),
    );
  }
}

fn default_force_using_admin_privileges() -> bool {
  false
}

fn validate_force_using_admin_privileges(config_str: &str, configuration_provider: &mut ConfigurationProvider) {
  if !config_str.contains(FORCE_USING_ADMIN_PRIVILEGES) {
    warn!(
      "[{}] was missing; adding it now with default value: {}",
      FORCE_USING_ADMIN_PRIVILEGES,
      default_force_using_admin_privileges()
    );
    configuration_provider.set_bool(FORCE_USING_ADMIN_PRIVILEGES, default_force_using_admin_privileges());
  }
}

fn default_additional_workspace_count() -> i32 {
  2
}

fn validate_workspace_count(config_str: &str, configuration_provider: &mut ConfigurationProvider) {
  if !config_str.contains(ADDITIONAL_WORKSPACE_COUNT) {
    warn!(
      "[{}] was missing; adding it now with default value: [{}]",
      ADDITIONAL_WORKSPACE_COUNT,
      default_additional_workspace_count()
    );
    configuration_provider.set_i32(ADDITIONAL_WORKSPACE_COUNT, default_additional_workspace_count());
  } else if configuration_provider.config.general.additional_workspace_count < 0 {
    warn!(
      "[{}] is negative, setting to default value: [{}]",
      ADDITIONAL_WORKSPACE_COUNT,
      default_additional_workspace_count()
    );
    configuration_provider.set_i32(ADDITIONAL_WORKSPACE_COUNT, default_additional_workspace_count());
  } else if configuration_provider.config.general.additional_workspace_count > 8 {
    warn!(
      "[{}] is larger than 8 which is not permitted, setting to 8",
      ADDITIONAL_WORKSPACE_COUNT,
    );
    configuration_provider.set_i32(ADDITIONAL_WORKSPACE_COUNT, 8);
  }
}

fn default_enable_features_using_mouse() -> bool {
  true
}

fn validate_features_using_mouse(config_str: &str, configuration_provider: &mut ConfigurationProvider) {
  if !config_str.contains(ENABLE_FEATURES_USING_MOUSE) {
    warn!(
      "[{}] was missing; adding it now with default value: {}",
      ENABLE_FEATURES_USING_MOUSE,
      default_enable_features_using_mouse()
    );
    configuration_provider.set_bool(ENABLE_FEATURES_USING_MOUSE, default_enable_features_using_mouse());
  }
}

fn default_delay_in_ms_before_dragging_is_allowed() -> i32 {
  DEFAULT_DELAY_IN_MS_BEFORE_DRAGGING_IS_ALLOWED
}

fn validate_delay_in_ms_before_dragging_is_allowed(config_str: &str, configuration_provider: &mut ConfigurationProvider) {
  if !config_str.contains(DELAY_IN_MS_BEFORE_DRAGGING_IS_ALLOWED) {
    warn!(
      "[{}] was missing; adding it now with default value: {}",
      DELAY_IN_MS_BEFORE_DRAGGING_IS_ALLOWED,
      default_delay_in_ms_before_dragging_is_allowed()
    );
    configuration_provider.set_i32(
      DELAY_IN_MS_BEFORE_DRAGGING_IS_ALLOWED,
      default_delay_in_ms_before_dragging_is_allowed(),
    );
  }
}

fn allow_moving_cursor_after_close_or_minimise() -> bool {
  true
}

fn validate_allow_moving_cursor_after_close_or_minimise(
  config_str: &str,
  configuration_provider: &mut ConfigurationProvider,
) {
  if !config_str.contains(ALLOW_MOVING_CURSOR_AFTER_OPEN_CLOSE_OR_MINIMISE) {
    warn!(
      "[{}] was missing; adding it now with default value: {}",
      ALLOW_MOVING_CURSOR_AFTER_OPEN_CLOSE_OR_MINIMISE,
      allow_moving_cursor_after_close_or_minimise()
    );
    configuration_provider.set_bool(
      ALLOW_MOVING_CURSOR_AFTER_OPEN_CLOSE_OR_MINIMISE,
      allow_moving_cursor_after_close_or_minimise(),
    );
  }
}

impl Default for GeneralConfiguration {
  fn default() -> Self {
    Self {
      window_margin: default_window_margin(),
      allow_selecting_same_center_windows: default_allow_selecting_same_center_windows(),
      force_using_admin_privileges: default_force_using_admin_privileges(),
      additional_workspace_count: default_additional_workspace_count(),
      enable_features_using_mouse: default_enable_features_using_mouse(),
      delay_in_ms_before_dragging_is_allowed: default_delay_in_ms_before_dragging_is_allowed(),
      allow_moving_cursor_after_close_or_minimise: allow_moving_cursor_after_close_or_minimise(),
    }
  }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CustomHotkey {
  pub name: String,
  pub path: String,
  pub hotkey: String,
  pub execute_as_admin: bool,
}

/// Settings for excluding certain windows from being managed by the application. This is useful for ignoring
/// system windows or other applications that should not be affected by this application at all i.e. they should not
/// be moved, selected, etc.
#[derive(Debug, Serialize, Deserialize)]
pub struct ExclusionSettings {
  #[serde(default = "default_excluded_window_titles")]
  pub window_titles: Vec<String>,
  #[serde(default = "default_excluded_window_classes")]
  pub window_class_names: Vec<String>,
}

impl Default for ExclusionSettings {
  fn default() -> Self {
    Self {
      window_titles: default_excluded_window_titles(),
      window_class_names: default_excluded_window_classes(),
    }
  }
}

fn default_excluded_window_titles() -> Vec<String> {
  vec![
    "Program Manager".to_string(),
    "Windows Input Experience".to_string(),
    "".to_string(),
    "Windows Shell Experience Host".to_string(),
    "ZPToolBarParentWnd".to_string(),
    "Settings".to_string(),
  ]
}

fn validate_excluded_window_titles(config_str: &str, configuration_provider: &mut ConfigurationProvider) {
  if !config_str.contains("window_titles") {
    warn!(
      "[{}] was missing; saving it now with default value: {:#?}",
      "window_titles",
      default_excluded_window_titles()
    );
    configuration_provider.save_config_or_log_error();
  }
}

fn default_excluded_window_classes() -> Vec<String> {
  vec![
    "Progman".to_string(),
    "WorkerW".to_string(),
    "Shell_TrayWnd".to_string(),
    "Shell_SecondaryTrayWnd".to_string(),
    "DV2ControlHost".to_string(),
  ]
}

fn validate_excluded_window_classes(config_str: &str, configuration_provider: &mut ConfigurationProvider) {
  if !config_str.contains("window_class_names") {
    warn!(
      "[{}] was missing; saving it now with default value: {:#?}",
      "window_class_names",
      default_excluded_window_classes()
    );
    configuration_provider.save_config_or_log_error();
  }
}

pub struct ConfigurationProvider {
  file_manager: FileManager<Configuration>,
  config: Configuration,
}

impl ConfigurationProvider {
  pub fn new() -> Self {
    let mut file_manager = FileManager::new(CONFIGURATION_FILE_NAME, FileType::Config);
    file_manager.set_content_prefix(CONFIGURATION_FILE_PREFIX);

    Self::new_with(file_manager)
  }

  fn new_with(file_manager: FileManager<Configuration>) -> Self {
    let (config, config_string) = file_manager.load_or_create().expect("Failed to load configuration");
    let mut configuration_provider = ConfigurationProvider { file_manager, config };
    configuration_provider.validate_config(config_string);

    configuration_provider
  }

  pub fn log_current_config(&self) {
    info!("{:?}", self.config);
  }

  // TODO: Consider validating hotkeys
  fn validate_config(&mut self, config_string: Option<String>) {
    if let Some(config_as_string) = config_string {
      validate_window_margin(&config_as_string, self);
      validate_allow_selecting_same_center_windows(&config_as_string, self);
      validate_force_using_admin_privileges(&config_as_string, self);
      validate_workspace_count(&config_as_string, self);
      validate_features_using_mouse(&config_as_string, self);
      validate_delay_in_ms_before_dragging_is_allowed(&config_as_string, self);
      validate_excluded_window_titles(&config_as_string, self);
      validate_excluded_window_classes(&config_as_string, self);
      validate_allow_moving_cursor_after_close_or_minimise(&config_as_string, self);
    } else {
      warn!("Failed to validate configuration: configuration string not available");
    }
  }

  pub fn get_bool(&self, name: &str) -> bool {
    match name {
      ALLOW_SELECTING_SAME_CENTER_WINDOWS => self.config.general.allow_selecting_same_center_windows,
      FORCE_USING_ADMIN_PRIVILEGES => self.config.general.force_using_admin_privileges,
      ENABLE_FEATURES_USING_MOUSE => self.config.general.enable_features_using_mouse,
      ALLOW_MOVING_CURSOR_AFTER_OPEN_CLOSE_OR_MINIMISE => self.config.general.allow_moving_cursor_after_close_or_minimise,
      &_ => {
        warn!("Failed to get configuration because [{name}] is unknown");

        false
      }
    }
  }

  /// Sets bool value and saves the configuration to file.
  pub fn set_bool(&mut self, name: &str, value: bool) {
    match name {
      ALLOW_SELECTING_SAME_CENTER_WINDOWS => self.config.general.allow_selecting_same_center_windows = value,
      FORCE_USING_ADMIN_PRIVILEGES => self.config.general.force_using_admin_privileges = value,
      ENABLE_FEATURES_USING_MOUSE => self.config.general.enable_features_using_mouse = value,
      ALLOW_MOVING_CURSOR_AFTER_OPEN_CLOSE_OR_MINIMISE => {
        self.config.general.allow_moving_cursor_after_close_or_minimise = value
      }
      &_ => {
        warn!("Failed to save configuration because [{name}] is unknown");
      }
    }
    self.save_config_or_log_error();
  }

  pub fn get_i32(&self, name: &str) -> i32 {
    match name {
      WINDOW_MARGIN => self.config.general.window_margin,
      ADDITIONAL_WORKSPACE_COUNT => self.config.general.additional_workspace_count,
      DELAY_IN_MS_BEFORE_DRAGGING_IS_ALLOWED => self.config.general.delay_in_ms_before_dragging_is_allowed,
      &_ => {
        warn!("Failed to get configuration because [{name}] is unknown");

        0
      }
    }
  }

  /// Sets i32 value and saves the configuration to file.
  pub fn set_i32(&mut self, name: &str, value: i32) {
    match name {
      WINDOW_MARGIN => self.config.general.window_margin = value,
      ADDITIONAL_WORKSPACE_COUNT => self.config.general.additional_workspace_count = value,
      DELAY_IN_MS_BEFORE_DRAGGING_IS_ALLOWED => self.config.general.delay_in_ms_before_dragging_is_allowed = value,
      &_ => {
        warn!("Failed to save configuration because [{name}] is unknown");
      }
    }
    self.save_config_or_log_error();
  }

  pub fn get_hotkeys(&self) -> &Vec<CustomHotkey> {
    &self.config.hotkey
  }

  pub fn get_exclusion_settings(&self) -> &ExclusionSettings {
    &self.config.exclusion_settings
  }

  pub fn reload_configuration(&mut self) {
    let (config, config_string) = self.file_manager.reload().expect("Failed to reload file");
    self.config = config;
    self.validate_config(config_string);
  }

  fn save_config_or_log_error(&mut self) {
    if let Err(err) = self.file_manager.save(&self.config) {
      error!("Failed to save configuration: {}", err);
    }
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::utils::create_temp_directory;
  use std::fs::{self, File};
  use std::io::Write;
  use std::path::PathBuf;

  impl ConfigurationProvider {
    pub fn default() -> Self {
      Self {
        file_manager: FileManager::default(),
        config: Configuration::default(),
      }
    }

    pub fn default_with_hotkeys(hotkeys: Vec<CustomHotkey>) -> Self {
      Self {
        file_manager: FileManager::default(),
        config: Configuration {
          general: GeneralConfiguration::default(),
          hotkey: hotkeys,
          exclusion_settings: ExclusionSettings::default(),
        },
      }
    }

    fn new_test(temp_path: PathBuf) -> Self {
      let file_manager = FileManager::new_test(temp_path);
      Self::new_with(file_manager)
    }

    fn new_test_without_validation(temp_path: PathBuf, config: Configuration) -> Self {
      let file_manager = FileManager::new_test(temp_path);
      Self { file_manager, config }
    }
  }

  #[test]
  fn new_with_file_manager_creates_default_when_file_does_not_exist() {
    let directory = create_temp_directory();
    let path = directory.path().join(CONFIGURATION_FILE_NAME);
    let configuration_provider = ConfigurationProvider::new_test(path.clone());

    let config = configuration_provider.config;
    assert_eq!(config.general.window_margin, DEFAULT_WINDOW_MARGIN_VALUE);
    assert!(config.general.allow_selecting_same_center_windows);
    assert_eq!(config.general.additional_workspace_count, 2);
    assert!(config.hotkey.is_empty());
    assert!(path.exists(), "Config file should have been created");
    let raw_contents = fs::read_to_string(path).expect("Should read the config file");
    let parsed_contents: Configuration = toml::from_str(&raw_contents).expect("Should parse valid TOML");
    assert_eq!(parsed_contents.general.window_margin, DEFAULT_WINDOW_MARGIN_VALUE);
  }

  #[test]
  fn new_with_file_manager_loads_existing_file() {
    let directory = create_temp_directory();
    let path = directory.path().join(CONFIGURATION_FILE_NAME);
    let custom_config = Configuration {
      general: GeneralConfiguration {
        window_margin: 50,
        allow_selecting_same_center_windows: false,
        force_using_admin_privileges: true,
        additional_workspace_count: 5,
        enable_features_using_mouse: true,
        delay_in_ms_before_dragging_is_allowed: 1000,
        allow_moving_cursor_after_close_or_minimise: false,
      },
      hotkey: vec![CustomHotkey {
        name: "Test App".to_string(),
        path: "C:\\test.exe".to_string(),
        hotkey: "y".to_string(),
        execute_as_admin: true,
      }],
      exclusion_settings: ExclusionSettings::default(),
    };
    let toml_string = toml::to_string_pretty(&custom_config).expect("Failed to serialize config");
    fs::write(&path, toml_string).expect("Failed to write config file");

    let configuration_provider = ConfigurationProvider::new_test(path);

    let loaded_config = configuration_provider.config;
    assert_eq!(loaded_config.general.window_margin, 50);
    assert!(!loaded_config.general.allow_selecting_same_center_windows);
    assert!(loaded_config.general.force_using_admin_privileges);
    assert_eq!(loaded_config.general.additional_workspace_count, 5);
    assert!(loaded_config.general.enable_features_using_mouse);
    assert_eq!(loaded_config.general.delay_in_ms_before_dragging_is_allowed, 1000);
    assert_eq!(loaded_config.hotkey.len(), 1);
    assert_eq!(loaded_config.hotkey[0].name, "Test App");
    assert!(loaded_config.hotkey[0].execute_as_admin);
    assert_eq!(
      loaded_config.exclusion_settings.window_titles,
      default_excluded_window_titles()
    );
    assert_eq!(
      loaded_config.exclusion_settings.window_class_names,
      default_excluded_window_classes()
    );
  }

  #[test]
  #[should_panic(expected = "Failed to load configuration")]
  fn new_with_file_manager_prevents_startup_when_invalid_toml_configuration() {
    let directory = create_temp_directory();
    let path = directory.path().join(CONFIGURATION_FILE_NAME);
    let mut file = File::create(&path).expect("Failed to create test file");
    file.write_all(b"this is not valid TOML]").expect("Failed to write test data");

    ConfigurationProvider::new_test(path);
  }

  #[test]
  fn new_with_file_manager_loads_file_with_missing_fields() {
    let directory = create_temp_directory();
    let path = directory.path().join(CONFIGURATION_FILE_NAME);
    let toml_string = r#"
      [general]
  
      [[hotkey]]
      name = "Test App"
      path = "C:\\test.exe"
      hotkey = "y"
      execute_as_admin = true
      "#;
    fs::write(&path, toml_string).expect("Failed to write config file");
    let configuration_provider = ConfigurationProvider::new_test(path);

    let loaded_config = configuration_provider.config;
    assert_eq!(loaded_config.general.window_margin, default_window_margin());
    assert_eq!(
      loaded_config.general.allow_selecting_same_center_windows,
      default_allow_selecting_same_center_windows(),
      "Should use default value for [default_allow_selecting_same_center_windows]"
    );
    assert_eq!(
      loaded_config.general.additional_workspace_count,
      default_additional_workspace_count(),
      "Should use default value for [default_additional_workspace_count]"
    );
    assert_eq!(loaded_config.hotkey.len(), 1);
    assert_eq!(loaded_config.hotkey[0].name, "Test App");
    assert_eq!(
      loaded_config.exclusion_settings.window_titles,
      default_excluded_window_titles(),
      "Should use default value for [default_excluded_window_titles]"
    );
    assert_eq!(
      loaded_config.exclusion_settings.window_class_names,
      default_excluded_window_classes(),
      "Should use default value for [default_excluded_window_classes]"
    );
  }

  #[test]
  fn validate_config_writes_missing_fields_to_file() {
    let directory = create_temp_directory();
    let path = directory.path().join(CONFIGURATION_FILE_NAME);
    let config_string = r#"
      [general]
      allow_selecting_same_center_windows = true
  
      "#;
    fs::write(&path, config_string).expect("Failed to write config file");
    let mut configuration_provider =
      ConfigurationProvider::new_test_without_validation(path.clone(), Configuration::default());

    // Prepare expected values
    let window_margin = format!("{} = {}", WINDOW_MARGIN, DEFAULT_WINDOW_MARGIN_VALUE);
    let allow_selecting_same_center_windows = format!(
      "{} = {}",
      ALLOW_SELECTING_SAME_CENTER_WINDOWS,
      default_allow_selecting_same_center_windows()
    );
    let additional_workspace_count = format!("{} = {}", ADDITIONAL_WORKSPACE_COUNT, default_additional_workspace_count());

    // Validate the config
    configuration_provider.validate_config(Some(config_string.into()));

    // After validation, the missing fields were added to the config string
    let config_string = fs::read_to_string(path).expect("Failed to read config file");
    assert!(config_string.contains(window_margin.as_str()));
    assert!(config_string.contains(allow_selecting_same_center_windows.as_str()));
    assert!(config_string.contains(additional_workspace_count.as_str()));
  }

  #[test]
  fn validate_config_updates_window_margin_if_negative_value_loaded() {
    let directory = create_temp_directory();
    let path = directory.path().join(CONFIGURATION_FILE_NAME);
    let config_string = r#"
      [general]
      window_margin = -10
      "#;
    fs::write(&path, config_string).expect("Failed to write config file");
    let mut configuration_provider =
      ConfigurationProvider::new_test_without_validation(path.clone(), Configuration::default());

    configuration_provider.validate_config(Some(config_string.into()));

    let config_string = fs::read_to_string(path).expect("Failed to read config file");
    assert!(config_string.contains("window_margin = 20"));
  }

  #[test]
  fn validate_config_updates_additional_workspace_count_if_loaded_value_exceeds_max() {
    let directory = create_temp_directory();
    let path = directory.path().join(CONFIGURATION_FILE_NAME);
    let config_string = r#"
      [general]
      additional_workspace_count = 15
      "#;
    fs::write(&path, config_string).expect("Failed to write config file");
    let mut config = Configuration::default();
    config.general.additional_workspace_count = 15;
    let mut configuration_provider = ConfigurationProvider::new_test_without_validation(path.clone(), config);

    configuration_provider.validate_config(Some(config_string.into()));

    let config_string = fs::read_to_string(path).expect("Failed to read config file");
    info!("[{}]", config_string);
    assert!(config_string.contains("additional_workspace_count = 8"));
    assert_eq!(configuration_provider.config.general.additional_workspace_count, 8);
  }

  #[test]
  fn reload_configuration_replaces_prior_configuration() {
    let directory = create_temp_directory();
    let path = directory.path().join(CONFIGURATION_FILE_NAME);
    let mut configuration_provider = ConfigurationProvider::new_test(path);

    let new_config = Configuration {
      general: GeneralConfiguration {
        window_margin: 100,
        allow_selecting_same_center_windows: true,
        force_using_admin_privileges: true,
        additional_workspace_count: 8,
        enable_features_using_mouse: false,
        delay_in_ms_before_dragging_is_allowed: 500,
        allow_moving_cursor_after_close_or_minimise: false,
      },
      hotkey: vec![CustomHotkey {
        name: "Test App".to_string(),
        path: "C:\\test.exe".to_string(),
        hotkey: "y".to_string(),
        execute_as_admin: true,
      }],
      exclusion_settings: ExclusionSettings::default(),
    };
    configuration_provider
      .file_manager
      .save(&new_config)
      .expect("Failed to write new config file");

    configuration_provider.reload_configuration();

    assert_eq!(configuration_provider.config.general.window_margin, 100);
    assert!(configuration_provider.config.general.allow_selecting_same_center_windows);
    assert!(configuration_provider.config.general.force_using_admin_privileges);
    assert_eq!(configuration_provider.config.general.additional_workspace_count, 8);
    assert!(!configuration_provider.config.general.enable_features_using_mouse);
    assert_eq!(
      configuration_provider.config.general.delay_in_ms_before_dragging_is_allowed,
      500
    );
    assert_eq!(configuration_provider.config.hotkey.len(), 1);
    assert_eq!(configuration_provider.config.hotkey[0].name, "Test App");
    assert!(configuration_provider.config.hotkey[0].execute_as_admin);
  }
}
